/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * Plotwist
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  GetMe200,
  GetUserById200,
  GetUserPreferences200,
  GetUsersAvailableEmail200,
  GetUsersAvailableEmail409,
  GetUsersAvailableEmailParams,
  GetUsersAvailableUsername200,
  GetUsersAvailableUsername409,
  GetUsersAvailableUsernameParams,
  GetUsersSearch200,
  GetUsersSearchParams,
  GetUsersUsername200,
  PatchUser200,
  PatchUserBody,
  PatchUserPassword200,
  PatchUserPasswordBody,
  PostUsersCreate201,
  PostUsersCreate409,
  PostUsersCreate500,
  PostUsersCreateBody,
  UpdateUserPreferences200,
  UpdateUserPreferencesBody
} from './endpoints.schemas';

import { axiosInstance } from '../services/axios-instance';





/**
 * Create a user
 */
export type postUsersCreateResponse201 = {
  data: PostUsersCreate201
  status: 201
}

export type postUsersCreateResponse409 = {
  data: PostUsersCreate409
  status: 409
}

export type postUsersCreateResponse500 = {
  data: PostUsersCreate500
  status: 500
}
    
export type postUsersCreateResponseSuccess = (postUsersCreateResponse201) & {
  headers: Headers;
};
export type postUsersCreateResponseError = (postUsersCreateResponse409 | postUsersCreateResponse500) & {
  headers: Headers;
};

export type postUsersCreateResponse = (postUsersCreateResponseSuccess | postUsersCreateResponseError)

export const getPostUsersCreateUrl = () => {


  

  return `/users/create`
}

export const postUsersCreate = async (postUsersCreateBody: PostUsersCreateBody, options?: RequestInit): Promise<postUsersCreateResponse> => {
  
  return axiosInstance<postUsersCreateResponse>(getPostUsersCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postUsersCreateBody,)
  }
);}




export const getPostUsersCreateMutationOptions = <TError = PostUsersCreate409 | PostUsersCreate500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersCreate>>, TError,{data: PostUsersCreateBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postUsersCreate>>, TError,{data: PostUsersCreateBody}, TContext> => {

const mutationKey = ['postUsersCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsersCreate>>, {data: PostUsersCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  postUsersCreate(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof postUsersCreate>>>
    export type PostUsersCreateMutationBody = PostUsersCreateBody
    export type PostUsersCreateMutationError = PostUsersCreate409 | PostUsersCreate500

    export const usePostUsersCreate = <TError = PostUsersCreate409 | PostUsersCreate500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsersCreate>>, TError,{data: PostUsersCreateBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postUsersCreate>>,
        TError,
        {data: PostUsersCreateBody},
        TContext
      > => {
      return useMutation(getPostUsersCreateMutationOptions(options), queryClient);
    }
    /**
 * Check if this username is available
 */
export type getUsersAvailableUsernameResponse200 = {
  data: GetUsersAvailableUsername200
  status: 200
}

export type getUsersAvailableUsernameResponse409 = {
  data: GetUsersAvailableUsername409
  status: 409
}
    
export type getUsersAvailableUsernameResponseSuccess = (getUsersAvailableUsernameResponse200) & {
  headers: Headers;
};
export type getUsersAvailableUsernameResponseError = (getUsersAvailableUsernameResponse409) & {
  headers: Headers;
};

export type getUsersAvailableUsernameResponse = (getUsersAvailableUsernameResponseSuccess | getUsersAvailableUsernameResponseError)

export const getGetUsersAvailableUsernameUrl = (params: GetUsersAvailableUsernameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users/available-username?${stringifiedParams}` : `/users/available-username`
}

export const getUsersAvailableUsername = async (params: GetUsersAvailableUsernameParams, options?: RequestInit): Promise<getUsersAvailableUsernameResponse> => {
  
  return axiosInstance<getUsersAvailableUsernameResponse>(getGetUsersAvailableUsernameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUsersAvailableUsernameQueryKey = (params?: GetUsersAvailableUsernameParams,) => {
    return [
    `/users/available-username`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetUsersAvailableUsernameQueryOptions = <TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersAvailableUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersAvailableUsername>>> = ({ signal }) => getUsersAvailableUsername(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersAvailableUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersAvailableUsername>>>
export type GetUsersAvailableUsernameQueryError = GetUsersAvailableUsername409


export function useGetUsersAvailableUsername<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersAvailableUsername>>,
          TError,
          Awaited<ReturnType<typeof getUsersAvailableUsername>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableUsername<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersAvailableUsername>>,
          TError,
          Awaited<ReturnType<typeof getUsersAvailableUsername>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableUsername<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersAvailableUsername<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersAvailableUsernameQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetUsersAvailableUsernameSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersAvailableUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersAvailableUsername>>> = ({ signal }) => getUsersAvailableUsername(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersAvailableUsernameSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersAvailableUsername>>>
export type GetUsersAvailableUsernameSuspenseQueryError = GetUsersAvailableUsername409


export function useGetUsersAvailableUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersAvailableUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError = GetUsersAvailableUsername409>(
 params: GetUsersAvailableUsernameParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableUsername>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersAvailableUsernameSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Check if this email is available
 */
export type getUsersAvailableEmailResponse200 = {
  data: GetUsersAvailableEmail200
  status: 200
}

export type getUsersAvailableEmailResponse409 = {
  data: GetUsersAvailableEmail409
  status: 409
}
    
export type getUsersAvailableEmailResponseSuccess = (getUsersAvailableEmailResponse200) & {
  headers: Headers;
};
export type getUsersAvailableEmailResponseError = (getUsersAvailableEmailResponse409) & {
  headers: Headers;
};

export type getUsersAvailableEmailResponse = (getUsersAvailableEmailResponseSuccess | getUsersAvailableEmailResponseError)

export const getGetUsersAvailableEmailUrl = (params: GetUsersAvailableEmailParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users/available-email?${stringifiedParams}` : `/users/available-email`
}

export const getUsersAvailableEmail = async (params: GetUsersAvailableEmailParams, options?: RequestInit): Promise<getUsersAvailableEmailResponse> => {
  
  return axiosInstance<getUsersAvailableEmailResponse>(getGetUsersAvailableEmailUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUsersAvailableEmailQueryKey = (params?: GetUsersAvailableEmailParams,) => {
    return [
    `/users/available-email`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetUsersAvailableEmailQueryOptions = <TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersAvailableEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersAvailableEmail>>> = ({ signal }) => getUsersAvailableEmail(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersAvailableEmailQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersAvailableEmail>>>
export type GetUsersAvailableEmailQueryError = GetUsersAvailableEmail409


export function useGetUsersAvailableEmail<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersAvailableEmail>>,
          TError,
          Awaited<ReturnType<typeof getUsersAvailableEmail>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableEmail<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersAvailableEmail>>,
          TError,
          Awaited<ReturnType<typeof getUsersAvailableEmail>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableEmail<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersAvailableEmail<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersAvailableEmailQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetUsersAvailableEmailSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersAvailableEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersAvailableEmail>>> = ({ signal }) => getUsersAvailableEmail(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersAvailableEmailSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersAvailableEmail>>>
export type GetUsersAvailableEmailSuspenseQueryError = GetUsersAvailableEmail409


export function useGetUsersAvailableEmailSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableEmailSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersAvailableEmailSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersAvailableEmailSuspense<TData = Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError = GetUsersAvailableEmail409>(
 params: GetUsersAvailableEmailParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersAvailableEmail>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersAvailableEmailSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get user by username
 */
export type getUsersUsernameResponse200 = {
  data: GetUsersUsername200
  status: 200
}
    
export type getUsersUsernameResponseSuccess = (getUsersUsernameResponse200) & {
  headers: Headers;
};
;

export type getUsersUsernameResponse = (getUsersUsernameResponseSuccess)

export const getGetUsersUsernameUrl = (username: string,) => {


  

  return `/users/${username}`
}

export const getUsersUsername = async (username: string, options?: RequestInit): Promise<getUsersUsernameResponse> => {
  
  return axiosInstance<getUsersUsernameResponse>(getGetUsersUsernameUrl(username),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUsersUsernameQueryKey = (username: string,) => {
    return [
    `/users/${username}`
    ] as const;
    }

    
export const getGetUsersUsernameQueryOptions = <TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersUsernameQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUsername>>> = ({ signal }) => getUsersUsername(username, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(username), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersUsername>>>
export type GetUsersUsernameQueryError = unknown


export function useGetUsersUsername<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUsername>>,
          TError,
          Awaited<ReturnType<typeof getUsersUsername>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersUsername<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersUsername>>,
          TError,
          Awaited<ReturnType<typeof getUsersUsername>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersUsername<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersUsername<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersUsernameQueryOptions(username,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetUsersUsernameSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(username: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersUsernameQueryKey(username);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUsername>>> = ({ signal }) => getUsersUsername(username, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersUsernameSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersUsername>>>
export type GetUsersUsernameSuspenseQueryError = unknown


export function useGetUsersUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersUsernameSuspense<TData = Awaited<ReturnType<typeof getUsersUsername>>, TError = unknown>(
 username: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersUsername>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersUsernameSuspenseQueryOptions(username,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get user by
 */
export type getUserByIdResponse200 = {
  data: GetUserById200
  status: 200
}
    
export type getUserByIdResponseSuccess = (getUserByIdResponse200) & {
  headers: Headers;
};
;

export type getUserByIdResponse = (getUserByIdResponseSuccess)

export const getGetUserByIdUrl = (id: string,) => {


  

  return `/user/by/${id}`
}

export const getUserById = async (id: string, options?: RequestInit): Promise<getUserByIdResponse> => {
  
  return axiosInstance<getUserByIdResponse>(getGetUserByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUserByIdQueryKey = (id: string,) => {
    return [
    `/user/by/${id}`
    ] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, { signal });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = unknown


export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetUserByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdSuspenseQueryError = unknown


export function useGetUserByIdSuspense<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByIdSuspense<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserByIdSuspense<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserByIdSuspense<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get information about the current user
 */
export type getMeResponse200 = {
  data: GetMe200
  status: 200
}
    
export type getMeResponseSuccess = (getMeResponse200) & {
  headers: Headers;
};
;

export type getMeResponse = (getMeResponseSuccess)

export const getGetMeUrl = () => {


  

  return `/me`
}

export const getMe = async ( options?: RequestInit): Promise<getMeResponse> => {
  
  return axiosInstance<getMeResponse>(getGetMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMeQueryKey = () => {
    return [
    `/me`
    ] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = unknown


export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetMeSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeSuspenseQueryError = unknown


export function useGetMeSuspense<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeSuspense<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMeSuspense<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMeSuspense<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update user
 */
export type patchUserResponse200 = {
  data: PatchUser200
  status: 200
}
    
export type patchUserResponseSuccess = (patchUserResponse200) & {
  headers: Headers;
};
;

export type patchUserResponse = (patchUserResponseSuccess)

export const getPatchUserUrl = () => {


  

  return `/user`
}

export const patchUser = async (patchUserBody: PatchUserBody, options?: RequestInit): Promise<patchUserResponse> => {
  
  return axiosInstance<patchUserResponse>(getPatchUserUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchUserBody,)
  }
);}




export const getPatchUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUser>>, TError,{data: PatchUserBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchUser>>, TError,{data: PatchUserBody}, TContext> => {

const mutationKey = ['patchUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUser>>, {data: PatchUserBody}> = (props) => {
          const {data} = props ?? {};

          return  patchUser(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchUserMutationResult = NonNullable<Awaited<ReturnType<typeof patchUser>>>
    export type PatchUserMutationBody = PatchUserBody
    export type PatchUserMutationError = unknown

    export const usePatchUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUser>>, TError,{data: PatchUserBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchUser>>,
        TError,
        {data: PatchUserBody},
        TContext
      > => {
      return useMutation(getPatchUserMutationOptions(options), queryClient);
    }
    /**
 * Update user password
 */
export type patchUserPasswordResponse200 = {
  data: PatchUserPassword200
  status: 200
}
    
export type patchUserPasswordResponseSuccess = (patchUserPasswordResponse200) & {
  headers: Headers;
};
;

export type patchUserPasswordResponse = (patchUserPasswordResponseSuccess)

export const getPatchUserPasswordUrl = () => {


  

  return `/user/password`
}

export const patchUserPassword = async (patchUserPasswordBody: PatchUserPasswordBody, options?: RequestInit): Promise<patchUserPasswordResponse> => {
  
  return axiosInstance<patchUserPasswordResponse>(getPatchUserPasswordUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchUserPasswordBody,)
  }
);}




export const getPatchUserPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUserPassword>>, TError,{data: PatchUserPasswordBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchUserPassword>>, TError,{data: PatchUserPasswordBody}, TContext> => {

const mutationKey = ['patchUserPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUserPassword>>, {data: PatchUserPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  patchUserPassword(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchUserPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof patchUserPassword>>>
    export type PatchUserPasswordMutationBody = PatchUserPasswordBody
    export type PatchUserPasswordMutationError = unknown

    export const usePatchUserPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUserPassword>>, TError,{data: PatchUserPasswordBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchUserPassword>>,
        TError,
        {data: PatchUserPasswordBody},
        TContext
      > => {
      return useMutation(getPatchUserPasswordMutationOptions(options), queryClient);
    }
    /**
 * Update user preferences
 */
export type updateUserPreferencesResponse200 = {
  data: UpdateUserPreferences200
  status: 200
}
    
export type updateUserPreferencesResponseSuccess = (updateUserPreferencesResponse200) & {
  headers: Headers;
};
;

export type updateUserPreferencesResponse = (updateUserPreferencesResponseSuccess)

export const getUpdateUserPreferencesUrl = () => {


  

  return `/user/preferences`
}

export const updateUserPreferences = async (updateUserPreferencesBody: UpdateUserPreferencesBody, options?: RequestInit): Promise<updateUserPreferencesResponse> => {
  
  return axiosInstance<updateUserPreferencesResponse>(getUpdateUserPreferencesUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserPreferencesBody,)
  }
);}




export const getUpdateUserPreferencesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserPreferences>>, TError,{data: UpdateUserPreferencesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUserPreferences>>, TError,{data: UpdateUserPreferencesBody}, TContext> => {

const mutationKey = ['updateUserPreferences'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserPreferences>>, {data: UpdateUserPreferencesBody}> = (props) => {
          const {data} = props ?? {};

          return  updateUserPreferences(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserPreferencesMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserPreferences>>>
    export type UpdateUserPreferencesMutationBody = UpdateUserPreferencesBody
    export type UpdateUserPreferencesMutationError = unknown

    export const useUpdateUserPreferences = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserPreferences>>, TError,{data: UpdateUserPreferencesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserPreferences>>,
        TError,
        {data: UpdateUserPreferencesBody},
        TContext
      > => {
      return useMutation(getUpdateUserPreferencesMutationOptions(options), queryClient);
    }
    /**
 * Get user preferences
 */
export type getUserPreferencesResponse200 = {
  data: GetUserPreferences200
  status: 200
}
    
export type getUserPreferencesResponseSuccess = (getUserPreferencesResponse200) & {
  headers: Headers;
};
;

export type getUserPreferencesResponse = (getUserPreferencesResponseSuccess)

export const getGetUserPreferencesUrl = () => {


  

  return `/user/preferences`
}

export const getUserPreferences = async ( options?: RequestInit): Promise<getUserPreferencesResponse> => {
  
  return axiosInstance<getUserPreferencesResponse>(getGetUserPreferencesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUserPreferencesQueryKey = () => {
    return [
    `/user/preferences`
    ] as const;
    }

    
export const getGetUserPreferencesQueryOptions = <TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserPreferencesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserPreferences>>> = ({ signal }) => getUserPreferences({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserPreferencesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserPreferences>>>
export type GetUserPreferencesQueryError = unknown


export function useGetUserPreferences<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPreferences>>,
          TError,
          Awaited<ReturnType<typeof getUserPreferences>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPreferences<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserPreferences>>,
          TError,
          Awaited<ReturnType<typeof getUserPreferences>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPreferences<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserPreferences<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserPreferencesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetUserPreferencesSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserPreferencesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserPreferences>>> = ({ signal }) => getUserPreferences({ signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserPreferencesSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUserPreferences>>>
export type GetUserPreferencesSuspenseQueryError = unknown


export function useGetUserPreferencesSuspense<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPreferencesSuspense<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserPreferencesSuspense<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserPreferencesSuspense<TData = Awaited<ReturnType<typeof getUserPreferences>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUserPreferences>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserPreferencesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get users by username
 */
export type getUsersSearchResponse200 = {
  data: GetUsersSearch200
  status: 200
}
    
export type getUsersSearchResponseSuccess = (getUsersSearchResponse200) & {
  headers: Headers;
};
;

export type getUsersSearchResponse = (getUsersSearchResponseSuccess)

export const getGetUsersSearchUrl = (params: GetUsersSearchParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users/search?${stringifiedParams}` : `/users/search`
}

export const getUsersSearch = async (params: GetUsersSearchParams, options?: RequestInit): Promise<getUsersSearchResponse> => {
  
  return axiosInstance<getUsersSearchResponse>(getGetUsersSearchUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetUsersSearchQueryKey = (params?: GetUsersSearchParams,) => {
    return [
    `/users/search`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetUsersSearchQueryOptions = <TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(params: GetUsersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersSearch>>> = ({ signal }) => getUsersSearch(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersSearch>>>
export type GetUsersSearchQueryError = unknown


export function useGetUsersSearch<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersSearch>>,
          TError,
          Awaited<ReturnType<typeof getUsersSearch>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersSearch<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersSearch>>,
          TError,
          Awaited<ReturnType<typeof getUsersSearch>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersSearch<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersSearch<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersSearchQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetUsersSearchSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(params: GetUsersSearchParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersSearch>>> = ({ signal }) => getUsersSearch(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersSearchSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersSearch>>>
export type GetUsersSearchSuspenseQueryError = unknown


export function useGetUsersSearchSuspense<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersSearchSuspense<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersSearchSuspense<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersSearchSuspense<TData = Awaited<ReturnType<typeof getUsersSearch>>, TError = unknown>(
 params: GetUsersSearchParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersSearch>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersSearchSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




