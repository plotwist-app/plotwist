/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * Plotwist
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  GetReviewReplies200Item,
  GetReviewRepliesParams,
  PostReviewReply201,
  PostReviewReply404,
  PostReviewReplyBody,
  PutReviewReplyById200,
  PutReviewReplyByIdBody
} from './endpoints.schemas';

import { axiosInstance } from '../services/axios-instance';





/**
 * Create a review reply
 */
export type postReviewReplyResponse201 = {
  data: PostReviewReply201
  status: 201
}

export type postReviewReplyResponse404 = {
  data: PostReviewReply404
  status: 404
}
    
export type postReviewReplyResponseSuccess = (postReviewReplyResponse201) & {
  headers: Headers;
};
export type postReviewReplyResponseError = (postReviewReplyResponse404) & {
  headers: Headers;
};

export type postReviewReplyResponse = (postReviewReplyResponseSuccess | postReviewReplyResponseError)

export const getPostReviewReplyUrl = () => {


  

  return `/review-reply`
}

export const postReviewReply = async (postReviewReplyBody: PostReviewReplyBody, options?: RequestInit): Promise<postReviewReplyResponse> => {
  
  return axiosInstance<postReviewReplyResponse>(getPostReviewReplyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postReviewReplyBody,)
  }
);}




export const getPostReviewReplyMutationOptions = <TError = PostReviewReply404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postReviewReply>>, TError,{data: PostReviewReplyBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postReviewReply>>, TError,{data: PostReviewReplyBody}, TContext> => {

const mutationKey = ['postReviewReply'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postReviewReply>>, {data: PostReviewReplyBody}> = (props) => {
          const {data} = props ?? {};

          return  postReviewReply(data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostReviewReplyMutationResult = NonNullable<Awaited<ReturnType<typeof postReviewReply>>>
    export type PostReviewReplyMutationBody = PostReviewReplyBody
    export type PostReviewReplyMutationError = PostReviewReply404

    export const usePostReviewReply = <TError = PostReviewReply404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postReviewReply>>, TError,{data: PostReviewReplyBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postReviewReply>>,
        TError,
        {data: PostReviewReplyBody},
        TContext
      > => {
      return useMutation(getPostReviewReplyMutationOptions(options), queryClient);
    }
    /**
 * Get review replies
 */
export type getReviewRepliesResponse200 = {
  data: GetReviewReplies200Item[]
  status: 200
}
    
export type getReviewRepliesResponseSuccess = (getReviewRepliesResponse200) & {
  headers: Headers;
};
;

export type getReviewRepliesResponse = (getReviewRepliesResponseSuccess)

export const getGetReviewRepliesUrl = (params: GetReviewRepliesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/review-replies?${stringifiedParams}` : `/review-replies`
}

export const getReviewReplies = async (params: GetReviewRepliesParams, options?: RequestInit): Promise<getReviewRepliesResponse> => {
  
  return axiosInstance<getReviewRepliesResponse>(getGetReviewRepliesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetReviewRepliesQueryKey = (params?: GetReviewRepliesParams,) => {
    return [
    `/review-replies`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetReviewRepliesQueryOptions = <TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(params: GetReviewRepliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewRepliesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewReplies>>> = ({ signal }) => getReviewReplies(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewRepliesQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewReplies>>>
export type GetReviewRepliesQueryError = unknown


export function useGetReviewReplies<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewReplies>>,
          TError,
          Awaited<ReturnType<typeof getReviewReplies>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewReplies<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewReplies>>,
          TError,
          Awaited<ReturnType<typeof getReviewReplies>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewReplies<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetReviewReplies<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewRepliesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetReviewRepliesSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(params: GetReviewRepliesParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewRepliesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewReplies>>> = ({ signal }) => getReviewReplies(params, { signal });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewRepliesSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewReplies>>>
export type GetReviewRepliesSuspenseQueryError = unknown


export function useGetReviewRepliesSuspense<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewRepliesSuspense<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewRepliesSuspense<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetReviewRepliesSuspense<TData = Awaited<ReturnType<typeof getReviewReplies>>, TError = unknown>(
 params: GetReviewRepliesParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getReviewReplies>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewRepliesSuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Delete review reply by id
 */
export type deleteReviewReplyByIdResponse200 = {
  data: void
  status: 200
}
    
export type deleteReviewReplyByIdResponseSuccess = (deleteReviewReplyByIdResponse200) & {
  headers: Headers;
};
;

export type deleteReviewReplyByIdResponse = (deleteReviewReplyByIdResponseSuccess)

export const getDeleteReviewReplyByIdUrl = (id: string,) => {


  

  return `/review-reply/by/${id}`
}

export const deleteReviewReplyById = async (id: string, options?: RequestInit): Promise<deleteReviewReplyByIdResponse> => {
  
  return axiosInstance<deleteReviewReplyByIdResponse>(getDeleteReviewReplyByIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteReviewReplyByIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReviewReplyById>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteReviewReplyById>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteReviewReplyById'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteReviewReplyById>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteReviewReplyById(id,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteReviewReplyByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteReviewReplyById>>>
    
    export type DeleteReviewReplyByIdMutationError = unknown

    export const useDeleteReviewReplyById = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteReviewReplyById>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteReviewReplyById>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getDeleteReviewReplyByIdMutationOptions(options), queryClient);
    }
    /**
 * Update review reply by id
 */
export type putReviewReplyByIdResponse200 = {
  data: PutReviewReplyById200
  status: 200
}
    
export type putReviewReplyByIdResponseSuccess = (putReviewReplyByIdResponse200) & {
  headers: Headers;
};
;

export type putReviewReplyByIdResponse = (putReviewReplyByIdResponseSuccess)

export const getPutReviewReplyByIdUrl = (id: string,) => {


  

  return `/review-reply/by/${id}`
}

export const putReviewReplyById = async (id: string,
    putReviewReplyByIdBody: PutReviewReplyByIdBody, options?: RequestInit): Promise<putReviewReplyByIdResponse> => {
  
  return axiosInstance<putReviewReplyByIdResponse>(getPutReviewReplyByIdUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putReviewReplyByIdBody,)
  }
);}




export const getPutReviewReplyByIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putReviewReplyById>>, TError,{id: string;data: PutReviewReplyByIdBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putReviewReplyById>>, TError,{id: string;data: PutReviewReplyByIdBody}, TContext> => {

const mutationKey = ['putReviewReplyById'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putReviewReplyById>>, {id: string;data: PutReviewReplyByIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  putReviewReplyById(id,data,)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PutReviewReplyByIdMutationResult = NonNullable<Awaited<ReturnType<typeof putReviewReplyById>>>
    export type PutReviewReplyByIdMutationBody = PutReviewReplyByIdBody
    export type PutReviewReplyByIdMutationError = unknown

    export const usePutReviewReplyById = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putReviewReplyById>>, TError,{id: string;data: PutReviewReplyByIdBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putReviewReplyById>>,
        TError,
        {id: string;data: PutReviewReplyByIdBody},
        TContext
      > => {
      return useMutation(getPutReviewReplyByIdMutationOptions(options), queryClient);
    }
    